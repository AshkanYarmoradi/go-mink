# GitHub Actions workflow for automatic releases with patch version increment
# Triggers on push to main branch and creates a new release with incremented version
# Example: v1.0.0 â†’ v1.0.1 â†’ v1.0.2

name: Release

on:
  push:
    branches:
      - main
    paths-ignore:
      - 'docs/**'
      - '*.md'
      - '.github/workflows/docs.yml'

permissions:
  contents: write

jobs:
  release:
    name: Create Release
    runs-on: ubuntu-latest
    
    steps:
      - name: Checkout code
        uses: actions/checkout@v6
        with:
          fetch-depth: 0  # Fetch all history for tags
          fetch-tags: true

      - name: Get latest tag
        id: get_tag
        run: |
          # Get the latest tag, default to v0.0.0 if no tags exist
          LATEST_TAG=$(git describe --tags --abbrev=0 2>/dev/null || echo "v0.0.0")
          echo "Latest tag: $LATEST_TAG"
          echo "latest_tag=$LATEST_TAG" >> $GITHUB_OUTPUT

      - name: Calculate next version
        id: next_version
        run: |
          LATEST_TAG="${{ steps.get_tag.outputs.latest_tag }}"
          
          # Remove 'v' prefix if present
          VERSION="${LATEST_TAG#v}"
          
          # Split version into parts
          IFS='.' read -r MAJOR MINOR PATCH <<< "$VERSION"
          
          # Increment patch version
          PATCH=$((PATCH + 1))
          
          # Construct new version
          NEW_VERSION="v${MAJOR}.${MINOR}.${PATCH}"
          
          echo "Previous version: $LATEST_TAG"
          echo "New version: $NEW_VERSION"
          echo "new_version=$NEW_VERSION" >> $GITHUB_OUTPUT

      - name: Generate changelog
        id: changelog
        run: |
          LATEST_TAG="${{ steps.get_tag.outputs.latest_tag }}"
          NEW_VERSION="${{ steps.next_version.outputs.new_version }}"
          
          # Get commit messages since last tag
          if [ "$LATEST_TAG" = "v0.0.0" ]; then
            # No previous tags, get all commits
            COMMITS=$(git log --pretty=format:"- %s (%h)" --no-merges -n 50)
          else
            COMMITS=$(git log ${LATEST_TAG}..HEAD --pretty=format:"- %s (%h)" --no-merges)
          fi
          
          # Create changelog content
          CHANGELOG="## What's Changed in ${NEW_VERSION}

          ${COMMITS}

          **Full Changelog**: https://github.com/${{ github.repository }}/compare/${LATEST_TAG}...${NEW_VERSION}"
          
          # Write to file for the release body
          echo "$CHANGELOG" > RELEASE_NOTES.md
          
          echo "Changelog generated"

      - name: Create tag
        run: |
          NEW_VERSION="${{ steps.next_version.outputs.new_version }}"
          
          git config user.name "github-actions[bot]"
          git config user.email "github-actions[bot]@users.noreply.github.com"
          
          git tag -a "$NEW_VERSION" -m "Release $NEW_VERSION"
          git push origin "$NEW_VERSION"
          
          echo "Tag $NEW_VERSION created and pushed"

      - name: Create GitHub Release
        uses: softprops/action-gh-release@a06a81a03ee405af7f2048a818ed3f03bbf83c7b # v2
        with:
          tag_name: ${{ steps.next_version.outputs.new_version }}
          name: Release ${{ steps.next_version.outputs.new_version }}
          body_path: RELEASE_NOTES.md
          draft: false
          prerelease: false
          generate_release_notes: false
          make_latest: true
        env:
          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}

      - name: Setup Go
        uses: actions/setup-go@v5
        with:
          go-version: '1.23'

      - name: Publish to Go Module Proxy
        run: |
          NEW_VERSION="${{ steps.next_version.outputs.new_version }}"
          MODULE="github.com/${{ github.repository }}"
          
          echo "Requesting module from Go proxy to trigger indexing..."
          
          # Request the module version from proxy.golang.org to trigger caching
          PROXY_URL="https://proxy.golang.org/${MODULE}/@v/${NEW_VERSION}.info"
          echo "Requesting: $PROXY_URL"
          
          # Retry up to 5 times with 10 second delays (proxy may need time to fetch)
          for i in {1..5}; do
            HTTP_STATUS=$(curl -s -o /dev/null -w "%{http_code}" "$PROXY_URL")
            echo "Attempt $i: HTTP $HTTP_STATUS"
            
            if [ "$HTTP_STATUS" = "200" ]; then
              echo "âœ… Module successfully indexed by Go proxy"
              break
            fi
            
            if [ $i -lt 5 ]; then
              echo "Waiting 10 seconds before retry..."
              sleep 10
            fi
          done
          
          # Also trigger pkg.go.dev to fetch the documentation
          PKG_URL="https://pkg.go.dev/${MODULE}@${NEW_VERSION}"
          echo "Module will be available at: $PKG_URL"
          
          # Request the module list to ensure it's fully indexed
          GOPROXY=https://proxy.golang.org go list -m "${MODULE}@${NEW_VERSION}" || true

      - name: Release summary
        run: |
          echo "## ðŸŽ‰ Release Created" >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY
          echo "**Version:** ${{ steps.next_version.outputs.new_version }}" >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY
          echo "**Previous:** ${{ steps.get_tag.outputs.latest_tag }}" >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY
          echo "[View Release](https://github.com/${{ github.repository }}/releases/tag/${{ steps.next_version.outputs.new_version }})" >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY
          echo "ðŸ“¦ **Go Module:** [pkg.go.dev/github.com/${{ github.repository }}@${{ steps.next_version.outputs.new_version }}](https://pkg.go.dev/github.com/${{ github.repository }}@${{ steps.next_version.outputs.new_version }})" >> $GITHUB_STEP_SUMMARY
